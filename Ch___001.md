>1

`username@hostname $`

`root@hostname #`

`$` 表示普通用户

`#` 表示管理员用户 root

>2


用 `bash xxxx.sh` 也可以执行脚本文件。

>3


命令的分隔通过 `换行` 或者 `;`

>4


`echo` 后打印的内容可以用 " "，' '，或者不加单双引号。

变量替换在 ' ' 中无效。

>5


用 `printf` 也可以打印，并且格式字符串的用法和 `C` 中差不多感觉，但 `printf` 不会自动添加换行。

>6


`echo -e` 使用转义序列
`echo -n` 不自动添加换行

打印彩色输出：`echo -e[1;31m This is red text \e[0m`

`-e[1;31m` 前面那个 `1` 和后面那个 `31` 分别代表什么颜色好不清楚。

#### 多换几个颜色玩玩试试 p6

>7


查看指定进程的环境变量：`cat /proc/$PID/environ | tr '\0' '\n'`

>8


在终端中输入的 `count=5` 并不是把 `count` 记录到了 `shell` 的环境变量中，直到调用了 `export count`，才会将 `count` 写入了环境变量。

子进程会继承父进程的环境变量：在 `shell` 中 `export count=5`，然后在脚本中 `echo $count` 验证下。

>9


获得字符串长度：`length=${#var}`

获取当前使用的 `shell`：`echo $SHELL` 或者 `echo $0`    

// 当前进程命令行的第 `1` 个参数，即程序的名字

>10


通过 `$UID` 检查当前用户是否是超级用户 `root`

>11


不但可以定义变量，还可以定义函数。

>12 `eval` 这玩意是个什么原理？？？【扫描两遍命令】


 #### 指针的例子:
 
 `x=150`
 
 `ptr=x`
 
 `eval echo \$$ptr`
 
  #### 取最后一个参数的例子：
 
 `print_last_arg() { eval echo \$$#; }`
 
  #### 书上的例子：神特么双引号...
 
`prepend() { [ -d "$2" ] && eval $1=\\"$2':'\\$$1\\" && export $1; }`
 
`prepend PATH /opt/myapp/bin`

`prepend LD_LIBRARY_PATH /opt/myapp/lib`
 
 
 >13
 
 `let` 后不用加 `$`
 
浮点数运算需要借助 `bc`，要将 `bc` 运算结果赋值给变量需要用 `echo`，比如：

~~~C
result=`echo "132 * 32" | bc`
echo $result

result=`echo "$a * $b" | bc`
echo $result
~~~

`bc` 可以设置精度，比如:

~~~C
echo "scale=5; 1/3" | bc
~~~

`bc` 可以指定输入进制和输出进制，顺序一定是 "obase=xx;ibase=xx;"，不能颠倒。 等到看 `CSAPP` 时，可以利用该指令轻松打印浮点数的二进制形式。

还有一个神奇的现象：

~~~C
➜  ~ echo "obase=2;ibase=10; 0.1" | bc
.0001
➜  ~ echo "obase=2;ibase=10; 0.100000" | bc
.00011001100110011001
➜  ~ echo "obase=2;ibase=10; 0.100000000000000" | bc
.00011001100110011001100110011001100110011001100110
➜  ~ 

~~~

计算平方根：echo "sqrt(100)" | bc
计算幂指数：echo "10^10" | bc
















